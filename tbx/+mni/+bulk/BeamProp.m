classdef BeamProp < mni.bulk.BulkData
    %BeamProp Describes the properties of a bulk.Beam object.
    %
    % The definition of the 'BeamProp' object matches that of the PBEAM
    % bulk data type from MSC.Nastran.
    %
    % Valid Bulk Data Types:
    %   - 'PBEAM'
    %   - 'PBAR'
    %   - 'PROD' - TODO
        
    methods % constructor
        function obj = BeamProp(varargin)
            
            %Initialise the bulk data sets
            addBulkDataSet(obj, 'PBAR', ...
                'BulkProps'  , {'PID', 'MID', 'A', 'I1', 'I2', 'J', 'NSM', 'C', 'D', 'E', 'F', 'K', 'I12'}, ...
                'PropTypes'  , {'i'  , 'i'  , 'r', 'r' , 'r' , 'r', 'r'  , 'r', 'r', 'r', 'r', 'r', 'r'}  , ...
                'PropDefault', {''   , ''   , 0  ,  0  , 0   , 0  , 0    , 0  , 0  , 0  , 0  , 0  , 0}    , ...
                'IDProp'     , 'PID', ...
                'PropMask'   , {'C', 2, 'D', 2, 'E', 2, 'F', 2, 'K', 2}, ...
                'Connections', {'MID', 'mni.bulk.Material', 'Materials'}, ...
                'AttrList'   , { ...
                'A', {'nonnegative'}, 'I1' , {'nonnegative'}, 'I2' , {'nonnegative'}, ...
                'J', {'nonnegative'}, 'C'  , {'nrows', 2}   , 'NSM', {'nonnegative'}, ...
                'D', {'nrows', 2}   , 'E'  , {'nrows', 2}   , 'F'  , {'nrows', 2}   , ...
                'K', {'nrows', 2}   , 'I12', {'nonnegative'}});
            addBulkDataSet(obj, 'PBEAM', ...
                'BulkProps'  , { ...
                'PID', 'MID', 'A_A', 'I1_A', 'I2_A', 'I12_A', 'J_A', 'NSM_A', ...
                'C_A', 'D_A', 'E_A', 'F_A', ...
                'SO', 'X_XB', 'A_B', 'I1_B', 'I2_B', 'I12_B', 'J_B', 'NSM_B', ...
                'C_B', 'D_B', 'E_B', 'F_B', ...
                'K', 'S', 'NSIA', 'NSIB', 'CW', ...
                'M_A', 'M_B', 'N_A', 'N_B'}, ...
                'PropTypes'  , { ...
                'i', 'i', 'r', 'r', 'r', 'r', 'r', 'r', ...
                'r', 'r', 'r', 'r', ...
                'c', 'r', 'r', 'r', 'r', 'r', 'r', 'r', ...
                'r', 'r', 'r', 'r', ...
                'r', 'r', 'r', 'r', 'r', ...
                'r', 'r', 'r', 'r'}, ...
                'PropDefault', { ...
                '', '', '', '', '', 0, 0, 0,  ...
                0 , 0 , 0 , 0 , ...
                '', '', 0 , 0 , 0 , 0, 0, 0, ...
                0 , 0 , 0 , 0 , ...
                1, 0, 0, 0, 0 , ...
                0, 0, 0, 0}, ...
                'PropMask'   , { ...
                'C_A', 2, 'D_A', 2, 'E_A', 2, 'F_A', 2, ...
                'C_B', 2, 'D_B', 2, 'E_B', 2, 'F_B', 2, ...
                'K'  , 2, 'S'  , 2, 'CW' , 2, 'M_A', 2, ...
                'M_B', 2, 'N_A', 2, 'N_B', 2}, ...
                'IDProp'     , 'PID', ...
                'Connections', {'MID', 'mni.bulk.Material', 'Materials'}, ...
                'AttrList'   , { ...
                'A_A' , {'nonnegative'}, 'I1_A', {'nonnegative'} , ...
                'I2_A', {'nonnegative'}, 'I12_A', {'nonnegative'}, ...
                'J_A' , {'nonnegative'}, 'NSM_A', {'nonnegative'}, ...
                'C_A' , {'nrows', 2}   , 'D_A'  , {'nrows', 2}   , ...
                'E_A' , {'nrows', 2}   , 'F_A'  , {'nrows', 2}   , ...
                'A_B' , {'nonnegative'}, 'I1_B' , {'nonnegative'}, ...
                'I2_B', {'nonnegative'}, 'I12_B', {'nonnegative'}, ...
                'J_B', {'nonnegative'} , 'NSM_B', {'nonnegative'}, ...
                'C_B', {'nrows', 2}    , 'D_B'  , {'nrows', 2}   , ...
                'E_B', {'nrows', 2}    , 'F_B'  , {'nrows', 2}   , ...
                'K'  , {'nrows', 2}    , 'S'    , {'nrows', 2}   , ...
                'CW' , {'nrows', 2}    , 'M_A'  , {'nrows', 2}   , ...
                'M_B', {'nrows', 2}    , 'N_A'  , {'nrows', 2}   , ...
                'N_B', {'nrows', 2}});
            varargin = parse(obj, varargin{:});
            preallocate(obj);
            
            if strcmp(obj.CardName, 'PBEAM')
                obj.BulkAssignFunction = @assignPBeamData;
            end
            
        end
    end
    
    methods % assigning data during import
        function assignH5BulkData(obj, bulkNames, bulkData)
            %assignH5BulkData Assigns the object data during the import
            %from a .h5 file.
            
            prpNames   = obj.CurrentBulkDataProps;
            
            %Build the prop data 
            prpData       = cell(size(prpNames));            
            prpData(ismember(prpNames, bulkNames)) = bulkData(ismember(bulkNames, prpNames));
            switch obj.CardName
                case 'PBAR' 
                    prpData{ismember(prpNames, 'C')}   = vertcat(bulkData{ismember(bulkNames, {'C1', 'C2'})});
                    prpData{ismember(prpNames, 'D')}   = vertcat(bulkData{ismember(bulkNames, {'D1', 'D2'})});
                    prpData{ismember(prpNames, 'E')}   = vertcat(bulkData{ismember(bulkNames, {'E1', 'E2'})});
                    prpData{ismember(prpNames, 'F')}   = vertcat(bulkData{ismember(bulkNames, {'F1', 'F2'})});
                    prpData{ismember(prpNames, 'K')}   = vertcat(bulkData{ismember(bulkNames, {'K1', 'K2'})});
                case 'PBEAM'
                    %SO must be "YES" "YESA" or "NO"
                    %   - Assume true is "YES" and false is "NO"
                    idxSO = ismember(prpNames, 'SO');
                    prpData{idxSO} = prpData{idxSO}(1, :); %One value per beam
                    idxYES = prpData{idxSO} == 1;
                    prpData{idxSO} = num2cell(prpData{idxSO});
                    prpData{idxSO}(idxYES)  = {'YES'};
                    prpData{idxSO}(~idxYES) = {'NO'};
                    %Combine other terms
                    %   - TODO - Should be possible to parameterise this!
                    prpData{ismember(prpNames, 'A_A')}   = bulkData{ismember(bulkNames, 'A')}(1, :);
                    prpData{ismember(prpNames, 'I1_A')}  = bulkData{ismember(bulkNames, 'I1')}(1, :);
                    prpData{ismember(prpNames, 'I2_A')}  = bulkData{ismember(bulkNames, 'I2')}(1, :);
                    prpData{ismember(prpNames, 'I12_A')} = bulkData{ismember(bulkNames, 'I12')}(1, :);
                    prpData{ismember(prpNames, 'J_A')}   = bulkData{ismember(bulkNames, 'J')}(1, :);
                    prpData{ismember(prpNames, 'NSM_A')} = bulkData{ismember(bulkNames, 'NSM')}(1, :);
                    prpData{ismember(prpNames, 'C_A')}   =  ...
                        [bulkData{ismember(bulkNames, 'C1')}(1, :) ; bulkData{ismember(bulkNames, 'C2')}(1, :) ];
                    prpData{ismember(prpNames, 'D_A')}   =  ...
                        [bulkData{ismember(bulkNames, 'D1')}(1, :) ; bulkData{ismember(bulkNames, 'D2')}(1, :) ];
                    prpData{ismember(prpNames, 'E_A')}   =  ...
                        [bulkData{ismember(bulkNames, 'E1')}(1, :) ; bulkData{ismember(bulkNames, 'E2')}(1, :) ];
                    prpData{ismember(prpNames, 'F_A')}   =  ...
                        [bulkData{ismember(bulkNames, 'F1')}(1, :) ; bulkData{ismember(bulkNames, 'F2')}(1, :) ];
                    prpData{ismember(prpNames, 'X_XB')} = ones(1, obj.NumBulk);
                    prpData{ismember(prpNames, 'A_B')}   = bulkData{ismember(bulkNames, 'A')}(end, :);
                    prpData{ismember(prpNames, 'I1_B')}  = bulkData{ismember(bulkNames, 'I1')}(end, :);
                    prpData{ismember(prpNames, 'I2_B')}  = bulkData{ismember(bulkNames, 'I2')}(end, :);
                    prpData{ismember(prpNames, 'I12_B')} = bulkData{ismember(bulkNames, 'I12')}(end, :);
                    prpData{ismember(prpNames, 'J_B')}   = bulkData{ismember(bulkNames, 'J')}(end, :);
                    prpData{ismember(prpNames, 'NSM_B')} = bulkData{ismember(bulkNames, 'NSM')}(end, :);
                    prpData{ismember(prpNames, 'C_B')}   =  ...
                        [bulkData{ismember(bulkNames, 'C1')}(end, :) ; bulkData{ismember(bulkNames, 'C2')}(end, :) ];
                    prpData{ismember(prpNames, 'D_B')}   =  ...
                        [bulkData{ismember(bulkNames, 'D1')}(end, :) ; bulkData{ismember(bulkNames, 'D2')}(end, :) ];
                    prpData{ismember(prpNames, 'E_B')}   =  ...
                        [bulkData{ismember(bulkNames, 'E1')}(end, :) ; bulkData{ismember(bulkNames, 'E2')}(end, :) ];
                    prpData{ismember(prpNames, 'F_B')}   =  ...
                        [bulkData{ismember(bulkNames, 'F1')}(end, :) ; bulkData{ismember(bulkNames, 'F2')}(end, :) ];
                    prpData{ismember(prpNames, 'K')}   = vertcat(bulkData{ismember(bulkNames, {'K1', 'K2'})});
                    prpData{ismember(prpNames, 'S')}   = vertcat(bulkData{ismember(bulkNames, {'S1', 'S2'})});
                    prpData{ismember(prpNames, 'CW')}   = vertcat(bulkData{ismember(bulkNames, {'CWA', 'CWB'})});
                    prpData{ismember(prpNames, 'M_A')}  = vertcat(bulkData{ismember(bulkNames, {'M1A', 'M2A'})});
                    prpData{ismember(prpNames, 'M_B')}  = vertcat(bulkData{ismember(bulkNames, {'M1B', 'M2B'})});
                    prpData{ismember(prpNames, 'N_A')}  = vertcat(bulkData{ismember(bulkNames, {'N1A', 'N2A'})});
                    prpData{ismember(prpNames, 'N_B')}  = vertcat(bulkData{ismember(bulkNames, {'N1A', 'N2A'})});
            end
            assignH5BulkData@mni.bulk.BulkData(obj, prpNames, prpData)
        end
        function assignPBeamData(obj, propData, index, BulkMeta)
            %assignPBeamData Assigns data for a PBeam entry to the object.
            %
            % Assumption: The PBEAM data is always fully populated i.e.
            % has 48 sets of data and only one continuation entry.
            
            % check ohow many beam ends have been submitted
            idx           = cellfun(@(x) any(contains(x, {'YES', 'YESA', 'NO'})), propData);
            if nnz(idx) > 1
                warning('Unable to handle PBEAM entries with more than one beam station. Update the code.');
            end
             
            %If J is not defined then it is the avergate of I1 & I2
            if isempty(propData{ismember(BulkMeta.Names, 'J_A')})
                propData{ismember(BulkMeta.Names, 'J_A')} = ...
                    0.5 * sum(str2num(vertcat(propData{ismember(BulkMeta.Names, {'I1_A', 'I2_A'})}))); %#ok<ST2NM>
            end
            
            %Deal with first 16 element (End-A)
            data_endA = propData(1 : 16);
            Meta_endA = struct('Names', {BulkMeta.Names(1 : 12)}, ...
                'Format'  , BulkMeta.Format(1 : 16)   , ...
                'Default' , {BulkMeta.Default(1 : 16)}, ...
                'Bounds'  , BulkMeta.Bounds(:, 1 : 12), ...
                'ListProp', {{}});
            assignCardData(obj, data_endA, index, Meta_endA);
            if length(propData)==16 || all(cellfun(@(x)~isempty(x),propData(17:end)))
                return
            end
            
            %Deal with End-B
            %   - Adjust bounds for indexing as we are dealing with a
            %     subset of the complete data
            idx  = any(contains(propData(17:32), {'YES', 'YESA', 'NO'}));
            if any(idx)
                data_endB = propData(17:32);
                Meta_endB = struct('Names', {BulkMeta.Names(13 : 24)}, ...
                    'Format'  , BulkMeta.Format(17 : 32)   , ...
                    'Default' , {BulkMeta.Default(17 : 32)}, ...
                    'Bounds'  , BulkMeta.Bounds(:, 13 : 24) - BulkMeta.Bounds(2, 12), ...
                    'ListProp', {{}});
                assignCardData(obj, data_endB, index, Meta_endB);
            end
            if length(propData)==32 || all(cellfun(@(x)~isempty(x),propData(32:end)))
                return
            end
            
            %Any remaining data is related to the last two continutations
            data_final = propData(32:end);
            Meta_final = struct('Names', {BulkMeta.Names(25 : end)}, ...
                'Format'  , BulkMeta.Format(33 : end)   , ...
                'Default' , {BulkMeta.Default(33 : end)}, ...
                'Bounds'  , BulkMeta.Bounds(:, 25 : end) - BulkMeta.Bounds(2, 24), ...
                'ListProp', {{}});
            assignCardData(obj, data_final, index, Meta_final);
            
        end
    end
    
end

